# lecture 2

### 컴퓨터는 어떻게 기록을 하는가

### Data Type (자료형)
- Data: 메모리에 넣을 값을 의미  
- Type: 그 해당 Data값의 종류(=크기)  -> 즉, **Data Type = 메모리에서 차지해야 할 크기를 의미함**  
-> 이때 값은 Memory에 들어가므로 Memory에 대한 이해 필요  

### Memory 
- 기원: on/off switch (0, 1을 표현/ 한 번 on을 해놓으면 계속 on인 상태로 있음)     
- **내가 원하는 상태, 값을 기억**할 수 있으면 모두 Memory라고 부름  
- Memory 하나하나를 부르는 Unit(단위)가 필요: bit (1bit = 0~1까지 두 개의 값을 표현할 수 있음)  
```
[Memory Unit]
1bit가 추가될 때마다 2의 n승만큼 커짐  
-> 8bit(0~255까지 표현 가능/ 256개를 표현할 수 있는 메모리를 확보한 것) = 1byte  
32bit 컴퓨터 -> 한 번에 메모리블럭을 4byte씩 쓰는 컴퓨터  
64bit 컴퓨터 -> 한 번에 8byte씩 쓸 수 있음  
```
- Memory의 특성: '메모리의 스위치의 현재 상태(값)이 무엇인지 + 주소(위치)가 어디인지'가 중요  
**이때 1byte일 때까지는 이해가 쉽지만 그 이상의 값은 어떻게 저장하지?  
-> 그 값이 주소 어디부터 어디까지를 사용하는지에 관한 크기 정보가 있어야만 함  
-> 값은 같아도 메모리블럭의 크기가 다를 경우, 표현 + 해석 자체가 달라짐**  
-> 메모리블럭의 크기를 알고 표시하는 것 필요

### 변수의 실체 = 메모리 주소의 별명
```
변수 예시)
var a = 3;
// a라고 하는 메모리 주소에 3이라는 값을 넣어달라
// 이때 변수는 크기도 알려줌
// 변수 = 메모리의 크기(차지해야 할 공간)와 메모리의 위치를 한 번에 가지고 있음
// 메모리의 크기 = 데이터 타입
```

### 언어마다 데이터 크기를 알려주는 별명이 따로 있음  
- 정확히 그 크기만큼 쓰지 않을 수도 있음  
- JS는 언어 자체에서 메모리에 차지할 공간을 넉넉하게 확보해둠  
- 따라서 메모리 효율성은 타언어에 비해서 떨어질 수 있음
- **JS는 숫자를 표시할 때, 64비트(=8바이트) 부동소수점 시스템을 사용**  
-> 따라서 JS에서는 ```var a=3;``` 이라고 선언하는 순간, a는 메모리의 8칸을 차지함  
-> 메모리에서 3칸을 차지하게끔 10이라는 값을 저장해뒀다면 꼭 그 **해당 위치**에서 찾아야 함  
-> 3칸 중에서 잘못된 위치에서 찾으면 원래 값이 아닌 틀린 값을 찾을 수도 있음  
-> C같은 언어에서는 메모리의 주소에 직접 접근, 변경할 수 있으므로 3칸 중 값이 들어있는 정확한 위치에만 접근하기도 함  
-> 그러나 JS는 언어 자체에서 무조건 8칸을 배정하고 특정 메모리 위치에 접근할 방법이 없음

### Javascript에서의 기본 자료형 = Data Type
- Javascript 변수는 형을 따로 표기하지 않지만 (various data type) 자세히 보면 안에 형을 가지고 있음

#### 1. "number"  
- 중간에 소수점 한 번 허용 (1.2) 
- 숫자 중간에 띄어쓰기를 하면 안됌 (1 1은 숫자로 인정되지 않음)  
- -는 숫자 표현의 일부가 아니라 연산자임
- 부호: 음수, 양수를 모두 다 쓰는 순간 원래 표현하려고 했던 숫자의 범위에서 50%만 표현 가능
- 양수만 사용할 때 unsigned 사용 (sign은 부호를 갖는다는 의미)  

#### 2. "string"  
- 한 문자열에 넣을 수 있는 데이터의 크기는 2기가. 사실상 무한에 가까움 (컴퓨터에서의 무한 = 데이터의 한계)  
- 문자열 연산자 '+': 숫자 덧셈 연산자와 동일하기 때문에 혼란 야기. 이항 중에 하나라도 숫자가 아니면 무조건 문자열 결합으로 계산함  
- 문자열: 문자가 열을 지어 있는 것. 각각 문자가 문자열에서 차지하는 위치는 인덱스라고 함
```javascript
var a = "안녕하세요";
a[2];
"하"; // 결과값
// 하위버전까지 지원할 때 써야 하는 메소드
a.charAt[2];
"하"; // 동일한 결과값
```
- 컴퓨터는 문자를 어떻게 저장하지?: 우리가 알고 있는 모든 문자를 숫자로 변화하는 표가 있음 -> 유니코드  
- 문자열끼리 크기 비교하는 방법: 문자열은 앞자리부터 비교해서 크면 뒷자리는 얼마나 길던지 상관없이 앞자리가 큰 문자열이 큰 것으로 인정

```javascript
'a' < 'b';
true; // 결과값  

'a'.charCodeAt(0);
// 위의 메소드를 활용하면 해당 문자의 숫자값이 나옴
// a = 65; 이고 b = 66; 이기 때문에 더 큰 값인 b가 win!
```

#### 3. "boolean"
- 이진의, 0과 1을 갖는 상태를 말함  
- 다른 리터럴처럼 8바이트를 차지함  
- 존재 이유: 비교연산자의 결과 값이기도 하기 때문. 즉, 비교연산자는 값이 하나로 수렴될 때 false, true 둘 중 하나로 나옴
- 논리 연산자의 종류:  
1) 논리 부정 연산자 (!): true -> false, false -> true로 바꿔주는 연산  
2) 논리합 연산자 (||): 합친 결과가 하나라도 참이면 참  
3) 논리곱 연산자 (&&): 오직 둘 다 참일때만 참으로 인정  
```javascript
3 < a < 7
컴퓨터에서 비교연산자가 나오면 항이 2개 필요하고 좌->우로 읽음
따라서 3 < a 에서 true 또는 false 값이 먼저 나옴
위의 결과값 즉, true 또는 false 값을 7과 비교하는 것이므로 비교 자체가 잘못된 것
``` 

#### 4. "object" 
#### 5. "function"
#### 6. "symbol"

```javascript
참고
[v-table (variable table): 변수 테이블]
이름과 주소와 데이터 타입을 매칭하는 표가 낮은 레벨에 있음
변수 사용하는 프로그래밍 언어는 모두 가지고 있음
```

### 출력
#### 컴퓨터의 5대 장치: 출력(컴퓨터의 내부사정을 보여주기 위한 장치), 입력, 주기억, 보조, 연산
**출력은 최대한 자주해서 컴퓨터의 현재 상태를 확인해보는 것이 현대 개발론에서 정한 원칙임**  
-> 확인을 거치지 않고 짠 코드를 나중에 디버깅하는 시간보다 출력을 자주 하며 꼼꼼하게 짜는 것이 시간이 절약되기 때문

### 함수 해석
- 함수가 호출되기 전에 항상 전달인자가 먼저 해석됨  
```javascript
console.log(1+2);
3; // 결과값
위 코드에서 console 객체가 3이라는 결과값을 출력할 수 있었던 이유: 괄호 안에 1+2의 결과값이 먼저 해석됐기 때문
즉, 1+2가 계산된 결과값 3이 console에 전달되니까 3이 출력된 것!  
```
```javascript
console.log(console.log(1));
1; // 첫 번째 결과값 : 가장 안쪽 괄호가 해석된 결과인 1이 찍힘
undefined // 두 번째 결과값 : 1을 출력한 console은 반환값이 없으므로 undefined를 찍음
undefined // 마지막 결과값 : 이를 감싼 console도 반환값이 없으므로 undefined를 찍음
```
